<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 中 Substring 的方法使用]]></title>
    <url>%2F%2Fpost%2Fswift-substring-methods.html</url>
    <content type="text"><![CDATA[在我初学 Java/C++ 时，经常遇到处理字符串的问题，很多都是截取字符串或者对字符串进行特定的处理。超级多的语法糖写起来很是方便，我曾经也是相信 Swift 在 String 类型上有很多的干货。但在 Swift 4 之前，其对字符串截取依然不是很方便。 最近写一个实验的时候发现 Swift 4 里出现了一个叫 Substring 的新特性，在 Java 里 Substring 是对字符串截取的一个方法，那在 Swift 里也是一样的，于是去看了下文档。在 Swift 4 里 String 变成一个集合类型，可以同 Array 等 Collection 类型一样方便的进行操作。 Substring 中的几个实用方法dropFirst我在实验中发现 Substring 的第一个方法是 func dropFirst(Int)，用法和他的名字一样，从集合开始删除的元素数量。 当然也有从后面删除的方法 func dropLast(Int) 12345let text = "hello world"let str = text.dropFirst(6)let string = text.dropLast(3)print(str) // worldprint(string) // hello wo prefixfunc prefix(_ maxLength: Int) -&gt; Substring 这个方法是截取你所需要字符串长度。例子如下： 12345let text = "hello world"let str = text.prefix(7)let string = text.prefix(15)print(str) // hello wprint(string) // hello world 与它相近的还有 suffix，它们很多方法可以使用，具体可以参考苹果的文档。 相关文档和参考资料前天我写完实验后仔细看了看完苹果的文档，还找到了卓大翻译了一篇相关文章，和图大去年写的文档，收获很多。还需努力学习。 Swift 中 Substring 与 String 你需要了解的 Swift 4 新东西之 Substring 此外还有一篇文章分析的也不错：swift4 为什么要整一个SubString]]></content>
      <categories>
        <category>iOS/macOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 的正则表达式与 I/O 处理总结]]></title>
    <url>%2F%2Fpost%2Fswift-regex-and-IO.html</url>
    <content type="text"><![CDATA[绝大多数编程语言可以进行正则匹配和文件的 I/O 操作，但也有方不方便的区别。比如你用 C/C++ 和 Java 那就很方便，当然 Python 写起来也很好。那么苹果最近一直强推的 Swift 语言呢？经过我一番试探，感觉其在文件，尤其是对文本文件操作有些不友好。毕竟现在很多数据都是存储在数据库或者简化为 JSON 格式了，没有必要按照初学 C 语言那样进行文本文件的按块/行读写操作了。但由于个人课程实验需要，于是用 Swift 写了一下，并总结出来一些点。 正则表达式如果不懂正则表达式的可以去看看正 则表达式 30 分钟入门教程 或者参考 8 个常用正则表达式 吧。 Swift 虽然是一门先进的编程语言，但至今为止并没有在语言层面上支持正则表达式。 可能是 app 并不需要处理很多文本匹配的功能，因此开发者不是很依赖正则表达式。但进行正则匹配的话，可以用 Cocoa 中的 NSRegularExpression 写一个简单的包装。喵神在其 《 Swift 必备 Tips 》 中写了一章正则的详解，如下： 1234567891011121314151617181920212223242526272829struct RegexHelper &#123; let regex: NSRegularExpression init(_ pattern: String) throws &#123; try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive) &#125; func match(_ input: String) -&gt; Bool &#123; let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count)) return matches.count &gt; 0 &#125;&#125;let mailPattern ="^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$"let matcher: RegexHelperdo &#123; matcher = try RegexHelper(mailPattern)&#125;let maybeMailAddress = "onev@onevcat.com"if matcher.match(maybeMailAddress) &#123; print("有效的邮箱地址")&#125; 这是一个简单的匹配判断，而我需要的是将匹配的结果返回，于是我参照喵神的代码和看 NSRegularExpression 文档 写了一个函数： 12345678910111213func matches(for regex: String, in text: String) -&gt; [String] &#123; do &#123; let regex = try NSRegularExpression(pattern: regex, options: .caseInsensitive) let nsString = text as NSString let results = regex.matches(in: text, options: [], range: NSMakeRange(0, nsString.length)) return results.map &#123; nsString.substring(with: $0.range) &#125; &#125; catch let error &#123; print("invalid regex : \(error.localizedDescription)") return [] &#125;&#125; 用法如下： 123let matched = matches(for: "([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)", in: "xxxxx@gmail.com,sss@gmail.com")print(matched) // ["xxxxx@gmail.com", "sss@gmail.com"] 这只是一个函数，如果有更高或者更灵活的需求，那么可以对 String进行一个扩展，就可以直接对字符串进行操作。这个函数写的就不如喵神的有更好的扩展性，但能满足一般使用了。 I/O 操作类似 C 语言文件操作如果想体验用 Swift 写类似 C 语言那种文件操作，那就有很多种方法。这里我不过多进行总结，可以自行谷歌，这里我放一个有关使用FileManager，FileHandle等类来实现的方法博客。 Swift - 文件，文件夹操作大全 这个博客可以说是总结很全了，也很详细。虽然代码是 Swift3.0 的，也使用于 Swift4.0 版本（不得不说 Swift 版本更新太坑了……）。 逐行读取文件基本上没人会真的需要逐行读取文件，iOS 开发中更没有从文件里逐行读取。但找这个相关功能文档时，发现真的有，方法很多种，都是用 Swift 写 macOS 应用的大神根据 Cocoa Streams 文档写的。 下面的代码出自 osx - 在Swift中逐行阅读文件/ URL 这个论坛。如果有误，希望大家告诉我原地址，再重新标明出处。 下面的方法是原作者根据 NSFileHandle 的相关文档及各种解决方案的启发。并使用了 guard 和新的 Data 值类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class StreamReader &#123; let encoding : String.Encoding let chunkSize : Int var fileHandle : FileHandle! let delimData : Data var buffer : Data var atEof : Bool init?(path: String, delimiter: String = "\n", encoding: String.Encoding = .utf8, chunkSize: Int = 4096) &#123; guard let fileHandle = FileHandle(forReadingAtPath: path), let delimData = delimiter.data(using: encoding) else &#123; return nil &#125; self.encoding = encoding self.chunkSize = chunkSize self.fileHandle = fileHandle self.delimData = delimData self.buffer = Data(capacity: chunkSize) self.atEof = false &#125; deinit &#123; self.close() &#125; /// Return next line, or nil on EOF. func nextLine() -&gt; String? &#123; precondition(fileHandle != nil, "Attempt to read from closed file") // Read data chunks from file until a line delimiter is found: while !atEof &#123; if let range = buffer.range(of: delimData) &#123; // Convert complete line (excluding the delimiter) to a string: let line = String(data: buffer.subdata(in: 0..&lt;range.lowerBound), encoding: encoding) // Remove line (and the delimiter) from the buffer: buffer.removeSubrange(0..&lt;range.upperBound) return line &#125; let tmpData = fileHandle.readData(ofLength: chunkSize) if tmpData.count &gt; 0 &#123; buffer.append(tmpData) &#125; else &#123; // EOF or read error. atEof = true if buffer.count &gt; 0 &#123; // Buffer contains last line in file (not terminated by delimiter). let line = String(data: buffer as Data, encoding: encoding) buffer.count = 0 return line &#125; &#125; &#125; return nil &#125; /// Start reading from the beginning of file. func rewind() -&gt; Void &#123; fileHandle.seek(toFileOffset: 0) buffer.count = 0 atEof = false &#125; /// Close the underlying file. No reading must be done after calling this method. func close() -&gt; Void &#123; fileHandle?.closeFile() fileHandle = nil &#125;&#125;extension StreamReader : Sequence &#123; func makeIterator() -&gt; AnyIterator&lt;String&gt; &#123; return AnyIterator &#123; return self.nextLine() &#125; &#125;&#125; 用法： 12345678if let aStreamReader = StreamReader(path: "/path/to/file") &#123; defer &#123; aStreamReader.close() &#125; while let line = aStreamReader.nextLine() &#123; print(line) &#125;&#125; 真心感谢原作者提供的方法，让我免去了重复造轮子的时间。 后记可以看出使用 Swift 进行文件操作是很不方便的。如果写的够多，并熟悉 Cocoa 框架的人来说，并没有多难。 正则和文件操作对 iOS/macOS 开发来说用的地方并不多，真正需要的地方也是很简单。如果再遇到这种实验课程，还是用 Java 吧！毕竟类多，方法多。]]></content>
      <categories>
        <category>iOS/macOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个壁纸应用的计划]]></title>
    <url>%2F%2Fpost%2Fwallpaper-ios-plan.html</url>
    <content type="text"><![CDATA[马上就是新的学期，假期折腾了乱七八糟的东西。渐渐的发现自己对一些壁纸的需求有点多，但很多壁纸软件上的图片千篇一律，也可能是个人审美不同，毕竟众口难调，于是想做一个属于自己的壁纸软件，也当来自己一个检验，并写下这篇文章来督促自己。下面是一个大体概括： 图片在一些无版权的图片网站。如 Unsplash 上挑选一些精美的图片，放到自己的服务器上。可以的话做一下分类，但精力有限。 iOS 客户端尽量简洁，去简单学一下 UI 设计，做一些简单人性化的交互。 网站 —— 有能力做就做毕竟图片放到服务器上是通过图床做的，可以的话做一个网站，也方便大家在电脑上使用并下载好看的图片。 后记至于能做成什么样就后说，慢慢开始做吧，骚年！]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VPS 推荐]]></title>
    <url>%2F%2Fpost%2Fvps-recommend.html</url>
    <content type="text"><![CDATA[上一篇文章说到，当你在搭建 Hexo 的时候可能会部署到自己的 VPS，那么就有小伙伴说了，我还没有 VPS 怎么办？两个方法，一是不用呗，又没有免费的 VPS 提供，干嘛要花不必要的钱。二是真的有钱而且想通过 VPS 做一些自己要做的东西花可以选择几家比较好的进行购买。 那么 VPS 除了可以托管网页还可以干嘛呢？那就有很多好玩的东西可以折腾了。比如爱国行为和自己的网盘资源中转等等。 VPS（注：如果你购买的是国内的 VPS 或者说服务器的话，并且你还需要域名解析，那么请你备案，否则网站将无法访问。） 系统选择如果只是搭建个人博客的话，推荐 CentOS，比较轻便而且资料也很多。此外你还想跑一些自己写的东西外，可以上 Ubuntu 和 Debian。这两个作为服务器来说很方便，其相关论坛和大神的教程还有一键脚本什么的都很多。 VPS 、虚拟主机还有 ECS 的区别这一项很难说清楚，建议大家去看一下知乎。如下：VPS 与虚拟主机有什么异同？然后大家可以根据自己的选择来挑选下面我列出来的几家服务商。 国内 VPS 推荐阿里云与阿里云国际阿里云的属于 ECS，当然也有虚拟主机。具体看自己的需求了。如果你是学生，而且只是做一个个人博客，可以选择阿里云的虚拟主机或 ECS。阿里云有学生优惠，其论坛上有好多文档和大神的教程。此外，阿里云还是不是的进行一些教程教学，是一个很不错的选择。 位置的选择的话，没有爱国者需求的话，尽可能的选择你所在的地区或者你需要面向人群所在的地区。阿里云香港一直是一个很不错的选择，但价格在那，看看就好。现在阿里云有活动，购买三年以上的服务器，只需要 888 元。这里就不给链接了，大家自行去其官网上看就好。 腾讯云腾讯云和阿里云一样都有学生优惠，并且学生优惠比阿里云更大，价格也很便宜。当初本人也在腾讯云上以低价（不到10块）弄到了腾讯云新加坡的机房服务器。不过现在学生优惠也买不到新加坡机房了，很是忧伤😔。机房位置选择如上，腾讯云和阿里云是差不多的。 腾讯云的域名很便宜的，而且你的网站需要备案的话，腾讯云还免费送幕布。感兴趣的同学去试一试吧！ 国外 VPS 推荐国外的服务器位置，如果想要美国的 IP 地址，那么我推荐美国西海岸的位置，或者 CN2 。不强求的话当然是离我国越近越好，比如香港，台湾，新加坡，日本。外国服务器只作为网站和个人博客的托管来说不算划算，但其不受备案的约束，依然是很多人的选择。希望大家酌情选择。 此外有些 VPS 商会判定你是否使用了代理，如果使用了代理，就会判定你为欺诈，并封停你的账户。 Digital OceanDigital Ocean （以下简称 DO ）也是一个老牌的 VPS 商，并且有大佬撑腰。那个大佬？当然是 GitHub 了。其速度稳定，但不算很快。为什么速度不快？因为已经被国内操烂了…… 由于有 GitHub 的学生优惠，惨遭国人使用搭建了很多爱国者工具，导致很多优化的线路，变得很是拥挤。但作为一个网站的托管来说不算太差，可以接受。详情可以见 GitHub 学生包。 但 DO 需要使用 PayPal 进行支付才可以使用，也就是说你必须充钱才可以用你的学生优惠。最低充值 5 刀，加上 GitHub 送的可以使用一年了。也不算太贵。PayPal 能绑定国内储值卡，但国内的 PayPal 有点略坑，有些外国企业店家不认国内注册的 Paypal。所以绑定需谨慎。 此外各种学生优惠可以参考 GitHub 上大神列出的学生优惠 Student-resources。 Linode这个老牌了，很好的服务商。还没有被国内操烂，因为其贵一些，对国内用户支付不友好。不太推荐，有钱大佬可以继续上。 Google Cloud Platform谷歌爸爸是真的牛逼，白送你 300 刀啊，白送！但你爸爸依然是你爸爸，想用 Google Cloud Platform（以下简称 GCP ）首先你需要一个梯子，一个谷歌账号和一张信用卡（最好是 visa 的或者万事达的全币种 / 双币种），注册好后，绑定信用卡之后。谷歌会从上面划走 $1，此时你需要确实一下就好，据说过段时间会还你。（ 并不清楚是否为真的 ） 反正 GCP 的门槛较高，而且如果信用卡的环节出问题会被封停服务的。300 刀，你需要在一年内用完，用不完就作废，其流量是收费的，具体的收费 GCP 的文档里有说明。这里就不过多阐述了。补充一句，GCP 的线路真的稳，尤其是台湾的线路，延迟 50 ms，真的爽。但作为网站托管来说有点不方便，做其他事还较为不错。酌情考虑。相关链接 需要梯子。 BandwagonHost老牌了，不用多说。网上很多人推荐搬瓦工，因为其有直连的 CN2 ，还有 20 刀的包年优惠，可以说很浪心了。不过 20 刀套餐不是随时都有的，需要的话要多留意。搬瓦工还支持支付宝，很方便。机房的选择最好选择多个那种，以防万一，还可以换。同样作为网站的托管和后台管理话，不算太合适。酌情选择。 VultrVultr 作为新起之秀，界面很美，性价比也很高，可谓是非常好了。有很多机房选择，并且机房可以随意切换，只要你把之前的删掉就可以了。最低 5 刀一个月，也有 2.5 刀每月的，不过经常售罄。对比上面的虽然没有学生优惠，但经常有注册送 10 刀和 3 刀的活动，多少也是送，有一点是一点。 Vultr 如果你想使用 Vultr 的话，点击这个链接进行注册充值，这样你可以获得额外的 10 刀。Vultr友情链接 后记VPS 的选择需要自己进行判断，很多性价比很高，但有很多限制。没有限制的，大多数贵。是时候祭出这张图了：]]></content>
      <categories>
        <category>Linux</category>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化与 Markdown 编辑器推荐]]></title>
    <url>%2F%2Fpost%2Fhexo-improve-summarize.html</url>
    <content type="text"><![CDATA[前言最近和一个朋友聊天的时候谈到了一些 hexo 的优化，并且给我提了一些建议，感受颇多。于是我就开始了新的折腾之旅，下面就是我这几天遇到的疑问和解决办法。 更新Hexo 更新及其插件更新Hexo更新网上有很多方法，但都没有怎么试验过，因为在我最后一次部署 Hexo 的时候它的版本号依然是 3.5.0。（如果下面方法不成功但话，就需要大家自行谷歌了） 小版本更新如果你进行的是小版本的更新可以这样 1$ npm update -g hexo 或者 1$ npm update 通过hexo -v可以查看版本是否变化。 大版本更新 通过官网和各种谷歌查到的命令和方法如下： 12$ npm install hexo-cli -g$ npm install 如果没有成功的话，需要重新定义在站点根目录下的package.json。 1234567&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.5.0&quot; &#125;, 将版本号改为最新版的版本号，再次执行上面的两个命令。 插件更新如果你不知道插件最新版本的话，可以通过npm outdated列出需要更新的插件名字和最新版本号。同样也有两种方法，任选其一就可以。 通过更改上述package.json文件中包含的插件版本号，并通过如下命令进行更新插件： 1$ npm update 当然你可以不修改任何文件通过如下命令更新 1$ npm install plugins-name@latest -S 其中plugins-name改为你想要更新的插件名字。 NexT 主题及其更新因为 NexT 主题在 GitHub 上迁移到新团队组织者名下，并且进入了6.0.x的新版本，优化不少，还添加很多新的留言模块，这些在下面会谈到。 从 5.1.x 更新如果你想从5.1.x更新到6.0.x，请看 这里 。 一般的更新你可以通过如下命令更新到最新的 master 分支： 12$ cd themes/next$ git pull 如果你遇到了这样的错误《Commit your changes or stash them before you can merge》这里有根据官方提供的两种方法，其中，第一个 Hexo 方法，现在不太适用于 Hexo 3.0 以上版本。因此我推荐用 NexT 方法，即将所有需要配置的放在hexo/source/_data/next.yml 下，如果在新的更新中出现了任何新的选项，你都只需从next/_config.yml复制出来放到source/_data/next.yml下，来配置你想要选项的。这个便是通过 Hexo 数据文件的方法进行的。具体步骤请看 Hexo 数据文件特性 进行更新。如果你是 Git 大神，想必自会解决吧！这里就不讨论使用 Git 的操作了。 还有问题的话，可以去 NexT在 Github 上的新仓库中去提 issues，并仔细阅读README。 Hexo 的部署和托管Hexo 博客的部署和托管有很多方式，最常见的，资料最多的就是通过 GitHub 来搭建 Hexo 博客，后期在部署到自己的 VPS 上，通过 VPS 上的 Web 服务器来访问博客的内容。也有人选择 Netlify 这种更加简单的托管方式，并且自动抓取你上传到 GitHub 的静态文件，通过绑定的域名访问。下面就分别介绍一下两者。 部署到自己的VPS当你自己有 VPS 的时候，自己博客可以同时托管到 GitHub 和 自己的 VPS 上。网上有很多教程，我列出两篇比较完整和相近的文章供大家参考。 如何将你的hexo博客部署在vps上？ Deploy Hexo Blog to VPS |部署Hexo博客到VPS 上述两篇文章的 VPS 上的 Web 服务器是 Nginx 。这种比较常见资料很多，功能也很强大，相对的就是配置较为麻烦。有的同学肯定会说看不懂啊什么的，那么就有一种好配置，自动化比较好的 Web 服务器 —— Caddy。当然这个配置简单但资料极少，感兴趣的同学可以去找找看。 VPS 就有很多比较好的商家，比如绑定 GitHub 学生套餐的 Digital Ocean，还有熟知 BandwagonHost （ 搬瓦工 ）和 支付更灵活的 Vultr 都很不错。这些我会在下一篇博客中介绍，并介绍一些爱国者工具。 Netlify 更加方便的托管服务商如果博客的内容不大，并且不想花钱买 VPS，还想一键就有 https 的保护，那么我推荐使用 Netlify ，非常省心。 使用 GitHub 账号登陆 Netlify。 登陆后，右上角选择New site from Git。 选择 Github ，然后关联包含网站源代码的仓库 设置，一路默认就好，如果你有自己的域名可以跟着提示一直走下去，将自己域名解析到 Netlify 服务器上。 域名设置。参考 Netlify 的详细说明文档。 HTTPS 设置。在 Domain management中，找到 HTTPS， 点击 Let’s Encrypt 就可以，变成下图：就可以了。从此你的站点加上了小锁，整个世界都美好了。 NexT 评论系统在最新的6.0.x版本里，NexT 集成了一些新的评论系统，除了老牌的 Disqus 以外，最让我心动是 Valine 和 Gitment 这两个。 Gitment其中 Gitment 是受 GitHub 的 issues 启发而开发的，还支持 Markdown 语法。一开始很喜欢很看好这个评论系统，但作者已经快一年没有更新过或者优化了。此外有一个缺点，就是不能匿名，必须登录 GitHub 账号，进行评论，并且每一篇文章需要自己稍微手动配置一下。最要命的是它是相当于 issues ，意味着你会不断的收到邮件提醒。所以我放弃了。 ValineValine 是我在查资料的时候看见有一个博主写了一篇关于它的文章。看了后，很是心动。虽然配置也有些繁琐但比 Gitment 好多了。正好新版的 NexT 集成了它，于是就用它了。 Valine，和 Gitment 具有相同的一点就是支持 Markdown 语法，此外它支持匿名和用邮箱登录。不同的是 Valine 的管理是通过 leancloud 完成的。意味着，你需要注册一个 leancloud，来完成相关的评论管理工作。这样已经很简单了。相比 Disqus 你需要采用代理来说很不错了。在最新的 NexT 里已经集成了，所以你只需在 leancloud 中建立应用，获取到其 appId, appKey 并在主题配置文件里找到 valine 的字段进行配置就好。同时你有自己的域名的话，为了你的数据安全，需要设置自己的安全域名。当然其他主题也可以进行配置，具体请参考 Valine 官网上的说明。 为什么不推荐其他的评论系统？因为其他的要不不干了，要不需要备案什么的比较麻烦。 （= = 我懒） SEO优化NexT 的 SEO 优化，我只推荐谷歌，不要问百度的怎么了。百度太特了，放着标准化的不用，非得用自己的。 Google Webmaster tools设置 Google站点管理工具 的验证字符串，用于提交 sitemap ( 在 Google Search Console 上有很多验证方式，这里推荐的是 NexT 官网上提供的验证方法。） 获取 google site verification code 登录 Google Webmaster Tools， 导航到验证方法，并选择 HTML Tag。将会获取到一段代码： 1&lt;meta name=&quot;google-site-verification&quot; content=&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot; /&gt; 将 content 里面的 XXXXXXXXXXXXXXXXXXXXXXX 复制出来。 设置主题。编辑主题配置文件，新增/修改字段 google_site_verification 1google_site_verification: XXXXXXXXXXXXXXXXXXXXXXX 提交 Sitemap 进入博客根目录，输入以下命令： 1$ npm install hexo-generator-sitemap --save 打开站点根目录下的 _config.yml，在最下方添加如下字段 12sitemap:path: sitemap.xml 然后执行如下命令 1$ hexo clean &amp;&amp; hexo g -d 进入 Google Search Console - 抓取 - 站点地图，点击「添加/测试站点地图」，输入你的博客网址。若无报错则站点地图提交成功 提交robots.txtrobots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。我的文件内容如下： 123User-agent: *Sitemap: https://liyafly.com/sitemap.xml robots.txt 文件更新至网站后可进入 Google Search Console - 抓取 - robots.txt 测试工具进行测试。 添加 descriptions对于每一篇文章我们都可以在 Front-matter 上添加 descriptions 来对我们的文章进行描述，方便搜索引擎找到你的博客具体如下： 12345678---title: ###date: ###categories: ###tags: ###keywords: ###descriptions: ###--- 注：如果descriptions写为description，则为文章的描述，在每篇文章标题下方显示，并且作为网页的 description 元数据。其在首页的显示作用相对于&lt;!-- more --&gt; 修改文章链接Hexo 默认的文章链接形式为 domain/year/month/day/postname，默认就是一个四级 url，并且可能造成 url 过长，对搜索引擎是十分不友好的，而且打开网站文件夹会很乱，我们可以将文章放入 post 里。编辑站点 _config.yml 文件，修改其中的 permalink 字段改为permalink: /post/:title.html即可。 Markdown 编辑器推荐Markdown 编辑器有很多很多种，真的要写一篇推荐的话，可能会有很多要介绍的。有时间，我也会专门写一篇文章来介绍。现在我就挑一些比较常用和好用的给大家。 简书比较喜欢写文章，而不注重技术类型，简书是一个不错的平台。当然在 17 年年末的时候出现了严重歧视程序员的事件，导致很多技术写作人员的转战其他平台。不介意的话可以在该平台写作。具有跨平台性。 文本编辑器 + 插件这类文本编辑器很多，比较常用的有Atom、Visual Studio Code、Sublime Text 3、Vim 等。 有很多插件，这里就不一一介绍了。这类比较轻便，而且用的多数是大神和单纯的写文章的人群。具有跨平台性，有良好的数学公式插件，自定义性强，方便显示。 laverna贴图方便。现在在用的新秀，功能基本都有，目前还没有看到付费计划，没有 Android 版本和 iOS 版本，其他三大平台都有。 MWeb独占 macOS 和 iOS 平台。对比其他的特优秀的写作软件来说，价格感人。功能很多：支持一键发布文章，一键上传图床，具有文档管理功能等等，特别好用的一个软件。但只可惜只在 Apple 的生态圈。此外，作者在官网上分享了很多小窍门。有兴趣的同学可以去看看。 2018.2.8 更新，完善内容并修改错别字。]]></content>
      <categories>
        <category>Hexo</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年新面貌]]></title>
    <url>%2F%2Fpost%2F%E6%96%B0%E5%B9%B4%E6%96%B0%E9%9D%A2%E8%B2%8C.html</url>
    <content type="text"><![CDATA[新的一年开始了，虽然已经过去了十二分之一，没有写年终总结但还是要迎接新面貌嘛。大学生活也已经度过了四分之三了，真的是很快，想想这几年的大学生活什么都没有记下来就有点亏亏的感觉，当然也是因为自己变的有点懒有关，只能赖自己太懒惰了。那么今年开始接着写东西吧。想当年，自己中二病的时候在新浪博客和 QQ 空间写下来不少文字，有诗歌有自己乱写的短篇小说，现在回想起来真的好中二，各种垃圾，还好都已经尘封了起来。自从 15 年入大学后，新浪博客已经基本不上了，QQ 空间里的文章都已经删了。久而久之，再也没有写过东西了。 在去年春天开学之后，正好看见我们老四在折腾 hexo 博客，突然又想写点东西了，也记录一下大学里学到的东西，做个笔记，日常和技术类型博客（当然是折腾无止境的思想指使着我干的）。这一折腾就是快一年啊，当时折腾的时候是为了选好看的主题而发愁，在主题官网看了好久也下了不少，好看的主题倒是不少，但都不是很喜欢的类型。想要比较简洁的而且定制性很强的主题，慢慢的发现 next 这个主题，于是开始研究如何配置起来好玩。（最新的next主题在GitHub上迁移到了新的组织名下，并做了一点点的完善，链接如下 https://github.com/theme-next/hexo-theme-next ) 这期间翻了不少博客和文档，也中断过很久，之后电脑重装过几次就放弃了在写博客的念头。总之在今天之前我是真的是在折腾而没有静下心来写下来一篇文章。曾经还想把如何搭建 hexo + GitHub 的博客写下来，但放弃了，因为它已经很多了而且很完善了，一搜就有很多，我再写也大抵相同，没有什么新意。直到年底，我又捡起了这个博客。原因还是那个，写写学到的内容，分享笔记和日常的技术博客，当然也为了督促自己。 新年新气象，新面貌，那就从这篇博客开始吧，也算立一个 flag，多写点博客，争取半个月一篇文章。emmmm，先这样吧。去看月全食的直播了。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
